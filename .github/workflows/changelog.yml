name: Changelog Management

on:
  push:
    branches: [main]
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'announcements/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '**/*.png'
      - '**/*.jpg'
      - '**/*.svg'
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force changelog update'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: changelog-${{ github.ref }}
  cancel-in-progress: true

env:
  CHANGELOG_FILE: CHANGELOG.md

jobs:
  update-changelog:
    name: Update Changelog
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install git-cliff
        run: |
          # Get the latest release version
          LATEST_VERSION=$(curl -s https://api.github.com/repos/orhun/git-cliff/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Installing git-cliff version: $LATEST_VERSION"
          
          # Try different URL formats for git-cliff
          SUCCESS=false
          
          # Format 1: Standard format
          if ! $SUCCESS; then
            echo "Trying standard format..."
            if curl -L "https://github.com/orhun/git-cliff/releases/download/${LATEST_VERSION}/git-cliff-${LATEST_VERSION}-x86_64-unknown-linux-gnu.tar.gz" | tar xz 2>/dev/null; then
              SUCCESS=true
              echo "✅ Downloaded using standard format"
            fi
          fi
          
          # Format 2: Without version prefix in filename
          if ! $SUCCESS; then
            echo "Trying alternative format..."
            VERSION_NO_V=${LATEST_VERSION#v}
            if curl -L "https://github.com/orhun/git-cliff/releases/download/${LATEST_VERSION}/git-cliff-${VERSION_NO_V}-x86_64-unknown-linux-gnu.tar.gz" | tar xz 2>/dev/null; then
              SUCCESS=true
              echo "✅ Downloaded using alternative format"
            fi
          fi
          
          # Format 3: Use GitHub CLI as fallback
          if ! $SUCCESS; then
            echo "Trying GitHub CLI download..."
            gh release download "${LATEST_VERSION}" --repo orhun/git-cliff --pattern "*x86_64-unknown-linux-gnu.tar.gz"
            tar xz -f git-cliff-*-x86_64-unknown-linux-gnu.tar.gz
            SUCCESS=true
            echo "✅ Downloaded using GitHub CLI"
          fi
          
          # Install the binary
          if [ -d git-cliff-* ]; then
            sudo mv git-cliff-*/git-cliff /usr/local/bin/
          elif [ -f git-cliff ]; then
            sudo mv git-cliff /usr/local/bin/
          else
            echo "❌ Could not find git-cliff binary"
            exit 1
          fi
          
          # Verify installation
          git-cliff --version
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if changelog update is needed
        id: check_update
        run: |
          # Get the last commit that modified the changelog
          LAST_CHANGELOG_COMMIT=$(git log -1 --format="%H" -- ${{ env.CHANGELOG_FILE }} 2>/dev/null || echo "")
          
          # Get the latest commit on main
          LATEST_COMMIT=$(git rev-parse HEAD)
          
          # Check if there are new commits since last changelog update
          if [ -z "$LAST_CHANGELOG_COMMIT" ] || [ "$LAST_CHANGELOG_COMMIT" != "$LATEST_COMMIT" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "Changelog update needed - new commits detected"
          else
            echo "update_needed=false" >> $GITHUB_OUTPUT
            echo "No changelog update needed - no new commits"
          fi
          
          # Force update if requested via workflow_dispatch
          if [ "${{ github.event.inputs.force_update }}" = "true" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "Forcing changelog update as requested"
          fi

      - name: Generate unreleased changelog
        if: steps.check_update.outputs.update_needed == 'true'
        run: |
          echo "Generating unreleased changelog entries..."
          
          # Create backup of current changelog
          cp ${{ env.CHANGELOG_FILE }} ${{ env.CHANGELOG_FILE }}.backup
          
          # Generate new changelog with unreleased entries
          git-cliff --unreleased --prepend ${{ env.CHANGELOG_FILE }}
          
          # Verify the changelog was updated
          if ! diff -q ${{ env.CHANGELOG_FILE }} ${{ env.CHANGELOG_FILE }}.backup > /dev/null; then
            echo "Changelog successfully updated with new unreleased entries"
            echo "changelog_updated=true" >> $GITHUB_ENV
          else
            echo "No new entries to add to changelog"
            echo "changelog_updated=false" >> $GITHUB_ENV
            # Restore backup if no changes
            mv ${{ env.CHANGELOG_FILE }}.backup ${{ env.CHANGELOG_FILE }}
          fi

      - name: Validate changelog format
        if: env.changelog_updated == 'true'
        run: |
          echo "Validating changelog format..."
          
          # Check if changelog has proper structure
          if ! grep -q "## \[Unreleased\]" ${{ env.CHANGELOG_FILE }}; then
            echo "Error: Changelog missing [Unreleased] section"
            exit 1
          fi
          
          # Check for proper markdown formatting
          if ! head -1 ${{ env.CHANGELOG_FILE }} | grep -q "# Changelog"; then
            echo "Error: Changelog missing proper header"
            exit 1
          fi
          
          echo "Changelog format validation passed"

      - name: Commit changelog updates
        if: env.changelog_updated == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add and commit the changelog
          git add ${{ env.CHANGELOG_FILE }}
          
          # Create commit message with details
          COMMIT_COUNT=$(git rev-list --count HEAD ^$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD))
          git commit -m "chore(changelog): update unreleased entries
          
          - Added $COMMIT_COUNT new commit(s) to unreleased section
          - Generated via automated changelog workflow
          - Ready for next release conversion
          
          [skip ci]"

      - name: Create changelog PR
        if: env.changelog_updated == 'true'
        run: |
          # Create a new branch for the changelog update
          BRANCH_NAME="chore/update-changelog-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"
          
          # Push the branch
          git push origin "$BRANCH_NAME"
          
          # Create a pull request using GitHub CLI
          echo "Creating pull request for changelog update..."
          
          # Create PR without labels first (more reliable)
          PR_URL=$(gh pr create \
            --title "chore(changelog): update unreleased entries" \
            --body "Automated changelog update with new unreleased entries.

          This PR was automatically generated by the changelog workflow.
          
          **Changes:**
          - Added new commit(s) to unreleased section
          - Generated via automated changelog workflow
          - Ready for next release conversion
          
          **Note:** This PR can be safely merged as it only updates the changelog." \
            --base main \
            --head "$BRANCH_NAME")
          
          echo "✅ Pull request created: $PR_URL"
          
          # Try to add labels after PR creation (optional)
          echo "Attempting to add labels..."
          gh pr edit "$BRANCH_NAME" --add-label "documentation" 2>/dev/null || echo "⚠️ Could not add 'documentation' label"
          gh pr edit "$BRANCH_NAME" --add-label "ci-cd" 2>/dev/null || echo "⚠️ Could not add 'ci-cd' label"
          
          # Try to enable auto-merge if possible
          gh pr merge "$BRANCH_NAME" --squash --auto || echo "⚠️ Could not enable auto-merge, manual review required"
          
          echo "Changelog PR created: $BRANCH_NAME"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create summary
        if: always()
        run: |
          echo "## 📝 Changelog Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_update.outputs.update_needed }}" = "true" ]; then
            if [ "${{ env.changelog_updated }}" = "true" ]; then
              echo "✅ **Changelog Updated Successfully**" >> $GITHUB_STEP_SUMMARY
              echo "- New unreleased entries have been added to ${{ env.CHANGELOG_FILE }}" >> $GITHUB_STEP_SUMMARY
              echo "- Pull request created for changelog updates" >> $GITHUB_STEP_SUMMARY
              echo "- Auto-merge enabled (if possible) for automated merging" >> $GITHUB_STEP_SUMMARY
              echo "- Ready for conversion to versioned release during next release" >> $GITHUB_STEP_SUMMARY
            else
              echo "ℹ️ **No Changelog Updates Needed**" >> $GITHUB_STEP_SUMMARY
              echo "- No new conventional commits found since last update" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "⏭️ **Changelog Update Skipped**" >> $GITHUB_STEP_SUMMARY
            echo "- No new commits detected since last changelog update" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "- Unreleased entries will be converted to versioned sections during release" >> $GITHUB_STEP_SUMMARY
          echo "- Release workflow will handle final changelog formatting" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          # Remove backup file if it exists
          rm -f ${{ env.CHANGELOG_FILE }}.backup